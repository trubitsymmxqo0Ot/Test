/*
    Существует так называемая пирамида тестирования. Она идет так:
    e2e тесты
    integration тесты
    скриншотные тесты
    unit тесты

    Тестирование как таковое нужно для того, чтобы описать некоторый сценарий, по которому функция должна работать. Если условный разработчик после нас
    придет работать с приложением и что-то поменяет в нем, то тест упадет и сообщит о том, что получил неожиданные данные. Тестирование как таковое не нужно
    для того, чтобы проверить как работает тот или иной блок кода.

    Как таковая цель тестирования - это проверка соотвествия по предъявленным требованиям. Своего рода это гарант, который гарантирует нам то, что приложение 
    не сломается, конечно, это не гарантия в 100%, но тем не менее, большинство обычных кейсов тесты закрывают.

    Чтобы как-то визуализировать, лучше пройтись на примере. Например, мы получаем дату с бэкенд приложения в виде timesstamp (миллисекундах), мы преобразовали
    это число в понятную для человека дату и на разработку пришел новый человек, что-то переписал и без тестов есть вероятность того, что дата начнет некорректно 
    обрабатываться, так как новый разработчик как-то под себя переписал функцию. Если бы мы прокрыли тестами такой кейс, то тесты упали бы и сообщили разработчику
    о том, что его функционал ломает тот, который уже был. Такой вид тестов помогает делать меньше регрессионных тестов.

    Регрессионные тесты - это тесты, которые после добавления нового функционала проверяют, не поломался ли старый функционал.

    Классификация тестов:
        Функциональное тестирование
            Модульное (unit)
            Интеграционное
            end-to-end (e2e)
        Нефункциональное тестирование
            Нагрузочное тестирование
            Тестирование безопасности
            Регрессионное тестирование
            и т.д.

    Конкретно в нашем случае мы будем рассматривать только функциональное тестирование.

    Пирамидой тестирования называется таковой именно из-за того, что условные unit тесты (самое последнее) должны быть чаще, чем e2e тесты (самое первое), то 
    есть, по сути, это пропорция тестов, которые мы должны писать. Повторим пирамиду ещё раз:
    e2e тесты
    integration тесты
    скриншотные тесты
    unit тесты

    Теперь поговорим о каждом модуле поподробнее: 
    unit - это тесты, которые пишутся на какие-то отдельные, независимые кусочки приложения, например функции, хелперы, методы класса или даже компонент с каким-то
    ui, вот пример:
    const sqaure = (value) => {
        if(number === 1){
            return 1
        }
        return Math.pow(value, 2);
    } - Возводит в квадрта

    const validateValue = (value) => {
        if(value < 0 || value > 100) {
            return false
        }
        return true;
    } - Проверяет, в нужном ли диапазоне число

    const mapArrToString = (arr) => {
        return arr
            .filter(item => Number.isInteger(item))
            .map(String);    
    } - Преобразует элемент массива (число) в строку 

    class HTMLParser {
        method1() {
            ...
        }
        method2() {
            ...
        }
        method3() {
            ...
        }
        method4() {
            ...
        }
    } - Отдельно, каждый метод классов тестируем.

    Скриншотные тесты - представим, что у нас есть ui и главная страница, на этой главной странице обязательно должен использовать шрифт Arial и никакой больше, 
    но спустя год на проект пришел новый разработчик, написал какое-то изменение в стилях и поменял шрифт, но по какой-то причине шрифт сменился и на главной странице.
    Так вот, скриншотные тесты на основе скрина сравнят эти две версии сайта, увидят о том, что произошло какое-то изменение и предупредят нас об этом. Если мы 
    укажем, что эти изменения валидны, то тогда будет сделан новый скриншот и уже на его основе будет сравнение со следующей версией сайта.

    integration - это когда мы что-то тестируем в связке. Например, несколько react компонентов в связке, несколько функций, несколько классов, реакт компоненты
    в связке с реакт роутером.

    e2e тесты - это когда мы на основе реальных данных, в реальном браузере, с реальным бэком пишем такой тест, который сам нажимает на кнопки, сам отправляет 
    какие-то данные. С помощью этих тестов мы проверяем какой-то ключевой функционал, например: страница оплаты, регистрация, удаление пользователя, в общем важный 
    функционал.

    Теоретически тестов должно быть:
    e2e - 10%, их самое маленькое количество, они долгие по выполнению, они тяжело поддерживаюся, их долго писать, они должны запускаться на каком-то удаленном 
    сервере, чтобы e2e тесты не запускались на версии сайта, которой пользуются и пользователи. В общем, с ними очень сложно работать, поэтому их нужно использовать
    только на какой-то ключевой функционал.
    integration - 20%-30%, они немного легче в поддержке, однако траты в плане времени при написании таких тестов тоже большие
    unit/скриншотные тесты - 70-80%, почти весь функционал, который можно вынести в модуль мы должны тестировать. Где скриншотные тесты - тесты для ui, а unit
    тесты - тесты для функциональности отдельно взятого модуля.

    Как подбирать данные для тестирования?
    Существует так называемый квадрат тестирования, где значения, которые попадают в центр этого квадрата считаются валидными, правильными, то есть, модуль, который
    получает данные всегда должен возращать true, поэтому один тест кейс мы всегда пишем на возврат true результата, второй тест кейс мы пишем на пограничные значения,
    мы должны убедиться, что на этих значениях нам функция возращает корректный результат. Также, всегда проверяем некорректные данные, то есть, берем 
    значение больше валидного, берем значение меньше валидного, если у нас 2d пространство, то тогда берем стороны (верх, низ, лево, право).

    Рассмотрим на примере:

    const validateValue = (value) => {
        if(value < 0 || value > 100) {
            return false
        }
        return true
    }
    
    console.log(validateValue(50));

    Тут у нас центром квадрата будет 50, т.к. это валидное значение. которое мы передаем.
    Проверяем пограничные значения, в нашем случае это 0 и 100, т.к. это крайние значения, при которых проверка вернет true
    Ну и неправильные значения - это будут -1 и 101 

*/