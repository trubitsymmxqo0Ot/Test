const square = require('./square2');

/*
    Существует такое понятие как мокать - мы можем мокать какие-то библиотеки, функции, либо методы, грубо говоря, мы говорим, что этот вызов функции
    возращает какое-то значение. С помощью toHaveBeenCalledTime мы можем узнать, сколько раз была вызвана тот или иной блок кода
*/

describe('Тесты', () => {

    test('Корректное значение', () => {
        const spyMathPow = jest.spyOn(Math, 'pow');
        square(2);
        expect(spyMathPow).toHaveBeenCalledTimes(1);
        /*
            Тут мы замокали метод pow у Math, далее, с помощью square мы передали значение 2, а 2 у нас не равно 1, поэтому мы попали на метод Math.pow, и ожидаем,
            что будет 1 вызов, собственно, в toHaveBeenCalledTimes мы и указали, что будет всего 1 вызов с цифрой 2.
        */
    })
    test('Новое значение', () => {
        const spyMathPow = jest.spyOn(Math, 'pow');
        square(1);
        expect(spyMathPow).toHaveBeenCalledTimes(0);
        /*
            Тут яркий пример стандартного поведения jest. Дело в том, что мы как бы передали 1, а 1 у нас равно 1, поэтому мы попадем в if, из которого
            только возращает 1, а Math.pow у нас не будет вызван. Тем не менее, почему я указал, что будет 1 вызов и он прошел? А все дело в том, что 
            тест, который был у нас до этого проходит и этот метод вызывается, то есть, мы передали в тесте ранее число 2, которое удовлетворяет для того,
            чтобы функция перешла к методу Math.pow, поэтому вызов фактически был и он засчитался и в новом тесте. Моки накапливают вызовы и чтобы такого
            избежать, нам перед каждым моком или после него нужно очищать мок, чтобы мы получали новые данные на каждый тест. (Я исправил toHaveBeenCalledTimes
            с 1 на 0, т.к. написал очищающее моки условие, но если его убрать, то вызов будет 1)
        */
    })
    afterEach(() => {
        jest.clearAllMocks();
    })
})